import 'error.dart';
import 'symbol_table.dart';
import 'token.dart';

class Interpreter {
  /*
  It contains methods that can be used to evaluate the syntax tree generated by the parser
   */

  late List<Map<String, dynamic>> _programBody;
  late SymbolTable _symbolTable;
  int _currLine = 1;

  Interpreter(Map<String, dynamic> parseTree) {
    /*
    Constructor
     */
    _programBody = parseTree["body"];
    _symbolTable = SymbolTable();
  }

  evaluateTree() {
    /*
    Evaluates the statement tree generated by the parser 
     */
    _programBody.forEach((statement) {
      _evaluateStatement(statement);
    });
  }

  _evaluateBinaryExpression(Map<String, dynamic> tree) {
    /*
    Evaluates the binary expressions
     */

    // left operand
    var left = _evaluateStatement(tree["left"]);

    // right operand
    var right = _evaluateStatement(tree["right"]);

    if (left["type"] == RunTimeTypes.Number &&
        right["type"] == RunTimeTypes.Number) {
      return _evaluateArithmeticExpression(left, right, tree["operator"]);
    }

    if (left["type"] == RunTimeTypes.String &&
        right["type"] == RunTimeTypes.String &&
        tree["operator"] == "+") {
      return _evaluateStringConcatenation(left, right, tree["operator"]);
    }

    if (left["type"] == RunTimeTypes.List &&
        right["type"] == RunTimeTypes.List &&
        tree["operator"] == "+") {
      return _evaluateListConcatenation(left, right, tree["operator"]);
    }
    throw TypeError(
        "Icompatible types for operator '${tree['operator']}'", _currLine);
  }

  _evaluateStringConcatenation(
      Map<String, dynamic> left, Map<String, dynamic> right, String operator) {
    return {
      "type": RunTimeTypes.String,
      "value": left["value"] + right["value"]
    };
  }

  _evaluateListConcatenation(
      Map<String, dynamic> left, Map<String, dynamic> right, String operator) {
    return {"type": RunTimeTypes.List, "value": left["value"] + right["value"]};
  }

  _evaluateArithmeticExpression(
      Map<String, dynamic> left, Map<String, dynamic> right, String operator) {
    /*
    Evaluates arithmetic expressions
    Returns the result of the operation and it's type
     */

    double result = 0;
    switch (operator) {
      case "+":
        result = left["value"] + right["value"];
        break;
      case "-":
        result = left["value"] - right["value"];
        break;
      case "*":
        result = left["value"] * right["value"];
        break;
      case "/":
        result = left["value"] / right["value"];
        break;
      case "%":
        result = left["value"] % right["value"];
        break;
    }
    return {"type": RunTimeTypes.Number, "value": result};
  }

  _evaluateLogicalExpression(Map<String, dynamic> tree) {
    /*
    Evaluates the logical expressions
     */

    // left operand
    var left = _evaluateStatement(tree["left"]);

    // right operand
    var right = _evaluateStatement(tree["right"]);

    if ((left["type"] == RunTimeTypes.Boolean &&
            right["type"] == RunTimeTypes.Boolean) ||
        (left["type"] == RunTimeTypes.Number &&
            right["type"] == RunTimeTypes.Number)) {
      return _evaluateLogicalOperation(left, right, tree["operator"]);
    }
    throw TypeError(
        "Icompatible types for operator '${tree['operator']}'", _currLine);
  }

  _evaluateLogicalOperation(
      Map<String, dynamic> left, Map<String, dynamic> right, String operator) {
    /*
    Evaluates logical operations
    Returns the result of the operation and it's type
     */

    bool result = false;
    if (left["type"] == RunTimeTypes.Boolean) {
      switch (operator) {
        case "and":
          result = left["value"] && right["value"];
          break;
        case "or":
          result = left["value"] || right["value"];
          break;
        case "==":
          result = left["value"] == right["value"];
          break;
        case "!=":
          result = left["value"] != right["value"];
          break;
        default:
          throw TypeError(
              "Icompatible types for operator '${operator}'", _currLine);
      }
    } else {
      switch (operator) {
        case ">":
          result = left["value"] > right["value"];
          break;
        case ">=":
          result = left["value"] >= right["value"];
          break;
        case "<":
          result = left["value"] < right["value"];
          break;
        case "<=":
          result = left["value"] <= right["value"];
          break;
        case "==":
          result = left["value"] == right["value"];
          break;
        case "!=":
          result = left["value"] != right["value"];
          break;
        default:
          throw TypeError(
              "Incompaible types for the operator '${operator}'", _currLine);
      }
    }

    return {"type": RunTimeTypes.Boolean, "value": result};
  }

  _evaluateUnaryExpression(Map<String, dynamic> tree) {
    /*
    Evaluates unary expressions
     */

    // determine operand (left or right)
    var value = tree["prefix"]
        ? _evaluateStatement(tree["right"])
        : _evaluateStatement(tree["left"]);

    // Differentiate logical and arithmetic unary operators
    if (tree["operator"] == "!") {
      return _evaluateLogicalUnary(value, tree["operator"]);
    } else {
      return _evaluateArithmeticUnary(value, tree["operator"]);
    }
  }

  _evaluateLogicalUnary(Map<String, dynamic> value, String operator) {
    /*
    Evaluates logical unary operations
    Returns the result of the operation and it's type
     */

    var result;
    if (value["type"] == RunTimeTypes.Boolean) {
      result = !(value["value"]);
    } else {
      throw TypeError(
          "Icompatible types for operator '${operator}'", _currLine);
    }
    return {"type": RunTimeTypes.Boolean, "value": result};
  }

  _evaluateArithmeticUnary(Map<String, dynamic> value, String operator) {
    /*
    Evaluates arithmetic unary operations
    Returns the result of the operation and it's type
     */

    var result;
    if (value["type"] == RunTimeTypes.Number) {
      if (operator == "-") {
        result = -1 * value["value"];
      } else {
        result = value["value"];
      }
    } else {
      throw TypeError(
          "Icompatible types for operator '${operator}'", _currLine);
    }
    return {"type": RunTimeTypes.Number, "value": result};
  }

  _evaluateIdentifier(Map<String, dynamic> tree) {
    /*
    Evaluates identifiers
    Returns the value of the identifier and it's type
     */

    return _symbolTable.lookup(tree["value"], _currLine);
  }

  _evaluateVariableDecleration(Map<String, dynamic> tree) {
    /*
    Evaluates variable decleration statements
    Returns the value of the identifier and it's type
     */

    var variable = tree["id"];
    Map<String, dynamic> value = _evaluateStatement(tree["init"]);
    _symbolTable.insert(variable, value, _currLine);
    return value;
  }

  _evaluateAssignment(Map<String, dynamic> tree) {
    /*
    Evaluates assignments statements
    Returns the value of the identifier and it's type
     */
    if (tree["left"]["type"] == TreeNodeTypes.Identifier) {
      var variable = tree["left"]["value"];
      Map<String, dynamic> value = _evaluateStatement(tree["right"]);

      _symbolTable.setAttribute(variable, value, _currLine);
      return value;
    } else if (tree["left"]["type"] == TreeNodeTypes.MemeberAccessExpression) {
      var list = _symbolTable.lookup(tree["left"]["value"], _currLine);
      var indexResult = _evaluateStatement(tree["left"]["index"]);
      if (indexResult["type"] != RunTimeTypes.Number ||
          indexResult["value"] < 0 ||
          indexResult["value"].floor() != indexResult["value"]) {
        throw TypeError("Invalid value for list index", _currLine);
      }
      if (indexResult["value"] < list["value"].length) {
        // print(list["value"][indexResult["value"].toInt()]);
        Map<String, dynamic> value = _evaluateStatement(tree["right"]);
        list["value"][indexResult["value"].toInt()] = value;
        _symbolTable.setAttribute(tree["left"]["value"], list, _currLine);
        return;
      } else {
        throw RangeError(
            "Invalid index value for list ${tree["value"]} ", _currLine);
      }
    } else {}
  }

  _evaluateInitStatement(Map<String, dynamic> tree) {
    /*
    Evaluates for loop initialization statement
     */

    _evaluateStatement(tree);
  }

  _evaluateTestCondition(Map<String, dynamic> tree) {
    /*
    Evaluates test condition statement for while loop, for loop and if statements
     */

    var result = _evaluateStatement(tree);

    // Ensure the test condition is always boolean type
    if (result["type"] != RunTimeTypes.Boolean) {
      throw TypeError("Test condition must be a Boolean type", _currLine);
    }
    return result;
  }

  _evaluateUpdateStatement(Map<String, dynamic> tree) {
    /*
    Evaluates for loop update statement
     */

    _evaluateStatement(tree);
  }

  _evaluateForStatement(Map<String, dynamic> tree) {
    /*
    Evaluates for loop
     */

    _symbolTable.allocate();

    // Evaluate init statement
    _evaluateInitStatement(tree["init"]);

    // Evaluate init condition and determine result
    Map<String, dynamic> result = _evaluateTestCondition(tree["test"]);

    // Until the condition is satisfied, evaluate the block statements
    while (result["value"]) {
      var blockResult = _evaluateBlockStatements(tree["body"]["body"]);
      if (blockResult["break"] ?? false) break;
      if (blockResult["return"] ?? false) return result;
      _evaluateUpdateStatement(tree["update"]);
      result = _evaluateTestCondition(tree["test"]);

      // if (result["break"]) break; no need to check
    }
    _symbolTable.free();
  }

  _evaluateBlockStatements(List<dynamic> body) {
    /*
    Evaluates block {} statements
    Returns values indicating appearances of break or continue statements
     */

    var result;
    for (int i = 0; i < body.length; i++) {
      result = {
        "break": false,
        "continue": false,
      };
      result = _evaluateStatement(body[i]) ?? result;
      if (result["break"] ?? false) {
        return {"break": true};
      }
      if (result["continue"] ?? false) {
        return {"continue": true};
      }
      if (result["return"] ?? false) {
        return result;
      }
    }
    return result;
  }

  _evaluateIfStatement(Map<String, dynamic> tree) {
    /*
    Evaluates if and elseif statements
    Returns values indicating appearances of break or continue statements
     */

    // Evaluate init condition and determine result
    Map<String, dynamic> result = _evaluateTestCondition(tree["test"]);
    var blockResult;

    // if the condition is satisfied, evaluate the block statements
    if (result["value"]) {
      _symbolTable.allocate();
      blockResult = _evaluateBlockStatements(tree["consequent"]["body"]);
      _symbolTable.free();
    } else {
      if (tree["alternate"] != null) {
        if (tree["alternate"]["type"] == TreeNodeTypes.IfStatement) {
          // Recursively check all the elseif statements if they satisfy the given condition
          _evaluateIfStatement(tree["alternate"]);
        } else {
          // Finally evaluate the else statement
          _symbolTable.allocate();
          blockResult = _evaluateBlockStatements(tree["alternate"]["body"]);
          _symbolTable.free();
        }
      }
    }
    return blockResult;
  }

  _evaluateWhileStatement(Map<String, dynamic> tree) {
    /*
    Evaluates while statements
     */

    _symbolTable.allocate();

    // Evaluate init condition and determine result
    Map<String, dynamic> result = _evaluateTestCondition(tree["test"]);

    // Until the condition is satidfied, evaluate the block statements
    while (result["value"]) {
      var blockResult = _evaluateBlockStatements(tree["body"]["body"]);
      if (blockResult["break"] ?? false) {
        break;
      }

      if (blockResult["return"] ?? false) {
        return blockResult;
      }

      // if (result["continue"]) continue; no need to check

      result = _evaluateTestCondition(tree["test"]);
    }
    _symbolTable.free();
  }

  _evaluatePrintStatement(Map<String, dynamic> tree) {
    /*
    Evaluates print statements
     */
    var result = _evaluateStatement(tree["value"]);
    switch (result["type"]) {
      case RunTimeTypes.List:
        List clean = [];
        for (int i = 0; i < result["value"].length; i++) {
          clean.add(result["value"][i]["value"]);
        }
        print(clean);
        break;
      case RunTimeTypes.Boolean:
        print(result["value"]);
        break;
      case RunTimeTypes.Number:
        print(result["value"]);
        break;
      case RunTimeTypes.String:
        print(result["value"]);
        break;
      case RunTimeTypes.Null:
        print(result["value"]);
        break;
      case RunTimeTypes.Function:
        print("<function>");
        break;
    }
  }

  _evaluateBreakStatement(Map<String, dynamic> tree) {
    /*
    Evaluates break statements
     */

    return {"break": true};
  }

  _evaluateContinueStatement(Map<String, dynamic> tree) {
    /*
    Evaluates continue statements
     */

    return {"continue": true};
  }

  _evaluateReturnStatement(Map<String, dynamic> tree) {
    /*
    Evaluates return statements
     */

    return {
      "return": true,
      "value": _evaluateStatement(tree["value"]),
    };
  }

  _evaluateFunctionDecleration(Map<String, dynamic> tree) {
    /*
    Evaluates function deleration statements
     */
    var funcName = tree["name"];
    Map<String, dynamic> value = {
      "params": tree["params"],
      "body": tree["body"],
      "defaultParamsCount": tree["defaultParamsCount"],
      "name": funcName,
      "line": tree["line"],
    };
    _symbolTable.insert(funcName, value, _currLine);
    // print(_symbolTable.lookup(funcName, _currLine));
    return value;
  }

  _evlauteFunctionCallStatement(Map<String, dynamic> tree) {
    var functionProperties = _symbolTable.lookup(tree["function"], _currLine);

    List<Map<String, dynamic>> evaluatedArgs = [];
    // print(functionProperties);

    for (int i = 0; i < tree["args"].length; i++) {
      evaluatedArgs.add(_evaluateStatement(tree["args"][i]));
    }

    if (tree["args"].length > functionProperties["params"].length) {
      throw RunTimeError(
          "Too many arguments to function ${tree["function"]}", _currLine);
    } else if (tree["args"].length <
        (functionProperties["params"].length -
            functionProperties["defaultParamsCount"])) {
      throw RunTimeError(
          "Too few arguments to function ${tree["function"]}", _currLine);
    } else {
      _symbolTable.allocate();
      _symbolTable.insert(
          functionProperties["name"], functionProperties, _currLine);
      for (int i = 0; i < functionProperties["params"].length; i++) {
        if (tree["args"].length > i) {
          _symbolTable.insert(
              functionProperties["params"][i]["value"] ??
                  functionProperties["params"][i]["left"]["value"],
              evaluatedArgs[i],
              functionProperties["line"]);
        } else {
          _symbolTable.insert(
              functionProperties["params"][i]["left"]["value"],
              _evaluateStatement(functionProperties["params"][i]["right"]),
              functionProperties["line"]);
        }
      }
      var blockResult =
          _evaluateBlockStatements(functionProperties["body"]["body"]);
      if (blockResult["return"] ?? false) {
        return blockResult["value"];
      } else {
        return {"type": RunTimeTypes.Null, "value": null};
      }
    }
  }

  _evaluateList(Map<String, dynamic> tree) {
    List<dynamic> evaluatedList = [];
    for (int i = 0; i < tree["value"].length; i++) {
      evaluatedList.add(_evaluateStatement(tree["value"][i]));
    }
    return {"type": RunTimeTypes.List, "value": evaluatedList};
  }

  _evaluateMemeberAccessExpression(Map<String, dynamic> tree) {
    var list = (_symbolTable.lookup(tree["value"], _currLine));
    var indexResult = _evaluateStatement(tree["index"]);
    if (indexResult["type"] != RunTimeTypes.Number ||
        indexResult["value"] < 0 ||
        indexResult["value"].floor() != indexResult["value"]) {
      throw TypeError("Invalid value for list index", _currLine);
    }
    if (indexResult["value"] < list["value"].length) {
      // print(list["value"][indexResult["value"].toInt()]);
      return list["value"][indexResult["value"].toInt()];
    } else {
      throw RangeError(
          "Invalid index value for list ${tree["value"]} ", _currLine);
    }
  }

  _evaluateStatement(Map<String, dynamic> statement) {
    /*
    Evaluates different statements
     */
    _currLine = statement["line"];
    switch (statement["type"]) {
      case TreeNodeTypes.FunctionCall:
        return _evlauteFunctionCallStatement(statement);
      case TreeNodeTypes.ReturnStatment:
        return _evaluateReturnStatement(statement);
      case TreeNodeTypes.FunctionDecleration:
        return _evaluateFunctionDecleration(statement);
      case TreeNodeTypes.BreakStatement:
        return _evaluateBreakStatement(statement);
      case TreeNodeTypes.ContinueStatement:
        return _evaluateContinueStatement(statement);
      case TreeNodeTypes.VariableDeclaration:
        return _evaluateVariableDecleration(statement);
      case TreeNodeTypes.Assignment:
        _evaluateAssignment(statement);
        break;
      case TreeNodeTypes.ForStatement:
        return _evaluateForStatement(statement);
      case TreeNodeTypes.IfStatement:
        return _evaluateIfStatement(statement);
      case TreeNodeTypes.WhileStatement:
        return _evaluateWhileStatement(statement);
      case TreeNodeTypes.PrintStatement:
        _evaluatePrintStatement(statement);
        break;
      case TreeNodeTypes.BinaryExpression:
        return _evaluateBinaryExpression(statement);
      case TreeNodeTypes.LogicalExpression:
        return _evaluateLogicalExpression(statement);
      case TreeNodeTypes.UnaryExpression:
        return _evaluateUnaryExpression(statement);
      case TreeNodeTypes.MemeberAccessExpression:
        return _evaluateMemeberAccessExpression(statement);
      case TreeNodeTypes.Identifier:
        return _evaluateIdentifier(statement);
      case TreeNodeTypes.List:
        return _evaluateList(statement);
      case TreeNodeTypes.Null:
        return {"type": RunTimeTypes.Null, "value": null};
      case TreeNodeTypes.Number:
        return {"type": RunTimeTypes.Number, "value": statement["value"]};
      case TreeNodeTypes.Boolean:
        return {"type": RunTimeTypes.Boolean, "value": statement["value"]};
      case TreeNodeTypes.String:
        return {"type": RunTimeTypes.String, "value": statement["value"]};
      default:
        break;
    }
  }
}
