import 'error.dart';
import 'symbol_table.dart';
import 'token.dart';

class Interpreter {
  /*
  It contains methods that can be used to evaluate the syntax tree generated by the parser
   */

  late List<Map<String, dynamic>> _programBody;
  late SymbolTable _symbolTable;
  int _currLine = 1;

  Interpreter(Map<String, dynamic> parseTree) {
    /*
    Constructor
     */
    _programBody = parseTree["body"];
    _symbolTable = SymbolTable();
  }

  evaluateTree() {
    /*
    Evaluates the statement tree generated by the parser 
     */
    _programBody.forEach((statement) {
      _evaluateStatement(statement);
    });
  }

  _evaluateBinaryExpression(Map<String, dynamic> tree) {
    /*
    Evaluates the binary expressions
     */

    // left operand
    var left = _evaluateStatement(tree["left"]);

    // right operand
    var right = _evaluateStatement(tree["right"]);

    if (left["type"] == RunTimeTypes.Number &&
        right["type"] == RunTimeTypes.Number) {
      return _evaluateArithmeticExpression(left, right, tree["operator"]);
    }
    throw TypeError(
        "Icompatible types for operator '${tree['operator']}'", _currLine);
  }

  _evaluateArithmeticExpression(
      Map<String, dynamic> left, Map<String, dynamic> right, String operator) {
    /*
    Evaluates arithmetic expressions
    Returns the result of the operation and it's type
     */

    double result = 0;
    switch (operator) {
      case "+":
        result = left["value"] + right["value"];
        break;
      case "-":
        result = left["value"] - right["value"];
        break;
      case "*":
        result = left["value"] * right["value"];
        break;
      case "/":
        result = left["value"] / right["value"];
        break;
      case "%":
        result = left["value"] % right["value"];
        break;
    }
    return {"type": RunTimeTypes.Number, "value": result};
  }

  _evaluateLogicalExpression(Map<String, dynamic> tree) {
    /*
    Evaluates the logical expressions
     */

    // left operand
    var left = _evaluateStatement(tree["left"]);

    // right operand
    var right = _evaluateStatement(tree["right"]);

    if ((left["type"] == RunTimeTypes.Boolean &&
            right["type"] == RunTimeTypes.Boolean) ||
        (left["type"] == RunTimeTypes.Number &&
            right["type"] == RunTimeTypes.Number)) {
      return _evaluateLogicalOperation(left, right, tree["operator"]);
    }
    throw TypeError(
        "Icompatible types for operator '${tree['operator']}'", _currLine);
  }

  _evaluateLogicalOperation(
      Map<String, dynamic> left, Map<String, dynamic> right, String operator) {
    /*
    Evaluates logical operations
    Returns the result of the operation and it's type
     */

    bool result = false;
    if (left["type"] == RunTimeTypes.Boolean) {
      switch (operator) {
        case "and":
          result = left["value"] && right["value"];
          break;
        case "or":
          result = left["value"] || right["value"];
          break;
        case "==":
          result = left["value"] == right["value"];
          break;
        case "!=":
          result = left["value"] != right["value"];
          break;
        default:
          throw TypeError(
              "Icompatible types for operator '${operator}'", _currLine);
      }
    } else {
      switch (operator) {
        case ">":
          result = left["value"] > right["value"];
          break;
        case ">=":
          result = left["value"] >= right["value"];
          break;
        case "<":
          result = left["value"] < right["value"];
          break;
        case "<=":
          result = left["value"] <= right["value"];
          break;
        case "==":
          result = left["value"] == right["value"];
          break;
        case "!=":
          result = left["value"] != right["value"];
          break;
        default:
          throw TypeError(
              "Incompaible types for the operator '${operator}'", _currLine);
      }
    }

    return {"type": RunTimeTypes.Boolean, "value": result};
  }

  _evaluateUnaryExpression(Map<String, dynamic> tree) {
    /*
    Evaluates unary expressions
     */

    // determine operand (left or right)
    var value = tree["prefix"]
        ? _evaluateStatement(tree["right"])
        : _evaluateStatement(tree["left"]);

    // Differentiate logical and arithmetic unary operators
    if (tree["operator"] == "!") {
      return _evaluateLogicalUnary(value, tree["operator"]);
    } else {
      return _evaluateArithmeticUnary(value, tree["operator"]);
    }
  }

  _evaluateLogicalUnary(Map<String, dynamic> value, String operator) {
    /*
    Evaluates logical unary operations
    Returns the result of the operation and it's type
     */

    var result;
    if (value["type"] == RunTimeTypes.Boolean) {
      result = !(value["value"]);
    } else {
      throw TypeError(
          "Icompatible types for operator '${operator}'", _currLine);
    }
    return {"type": RunTimeTypes.Boolean, "value": result};
  }

  _evaluateArithmeticUnary(Map<String, dynamic> value, String operator) {
    /*
    Evaluates arithmetic unary operations
    Returns the result of the operation and it's type
     */

    var result;
    if (value["type"] == RunTimeTypes.Number) {
      if (operator == "-") {
        result = -1 * value["value"];
      } else {
        result = value["value"];
      }
    } else {
      throw TypeError(
          "Icompatible types for operator '${operator}'", _currLine);
    }
    return {"type": RunTimeTypes.Number, "value": result};
  }

  _evaluateIdentifier(Map<String, dynamic> tree) {
    /*
    Evaluates identifiers
    Returns the value of the identifier and it's type
     */

    return _symbolTable.lookup(tree["value"], _currLine);
  }

  _evaluateVariableDecleration(Map<String, dynamic> tree) {
    /*
    Evaluates variable decleration statements
    Returns the value of the identifier and it's type
     */

    var variable = tree["id"];
    Map<String, dynamic> value = _evaluateStatement(tree["init"]);
    _symbolTable.insert(variable, value, _currLine);
    return value;
  }

  _evaluateAssignment(Map<String, dynamic> tree) {
    /*
    Evaluates assignments statements
    Returns the value of the identifier and it's type
     */

    var variable = tree["left"]["value"];
    Map<String, dynamic> value = _evaluateStatement(tree["right"]);

    _symbolTable.setAttribute(variable, value, _currLine);
    return value;
  }

  _evaluateInitStatement(Map<String, dynamic> tree) {
    /*
    Evaluates for loop initialization statement
     */

    _evaluateStatement(tree);
  }

  _evaluateTestCondition(Map<String, dynamic> tree) {
    /*
    Evaluates test condition statement for while loop, for loop and if statements
     */

    var result = _evaluateStatement(tree);

    // Ensure the test condition is always boolean type
    if (result["type"] != RunTimeTypes.Boolean) {
      throw TypeError("Test condition must be a Boolean type", _currLine);
    }
    return result;
  }

  _evaluateUpdateStatement(Map<String, dynamic> tree) {
    /*
    Evaluates for loop update statement
     */

    _evaluateStatement(tree);
  }

  _evaluateForStatement(Map<String, dynamic> tree) {
    /*
    Evaluates for loop
     */

    _symbolTable.allocate();

    // Evaluate init statement
    _evaluateInitStatement(tree["init"]);

    // Evaluate init condition and determine result
    Map<String, dynamic> result = _evaluateTestCondition(tree["test"]);

    // Until the condition is satisfied, evaluate the block statements
    while (result["value"]) {
      var blockResult = _evaluateBlockStatements(tree["body"]["body"]);
      if (blockResult["break"] ?? false) break;
      _evaluateUpdateStatement(tree["update"]);
      result = _evaluateTestCondition(tree["test"]);

      // if (result["break"]) break; no need to check
    }
    _symbolTable.free();
  }

  _evaluateBlockStatements(List<dynamic> body) {
    /*
    Evaluates block {} statements
    Returns values indicating appearances of break or continue statements
     */

    var result;
    for (int i = 0; i < body.length; i++) {
      result = {
        "break": false,
        "continue": false,
      };
      result = _evaluateStatement(body[i]) ?? result;
      if (result["break"] ?? false) {
        return {"break": true};
      }
      if (result["continue"] ?? false) {
        return {"continue": true};
      }
    }
    return result;
  }

  _evaluateIfStatement(Map<String, dynamic> tree) {
    /*
    Evaluates if and elseif statements
    Returns values indicating appearances of break or continue statements
     */

    // Evaluate init condition and determine result
    Map<String, dynamic> result = _evaluateTestCondition(tree["test"]);
    var blockResult;

    // if the condition is satisfied, evaluate the block statements
    if (result["value"]) {
      _symbolTable.allocate();
      blockResult = _evaluateBlockStatements(tree["consequent"]["body"]);
      _symbolTable.free();
    } else {
      if (tree["alternate"] != null) {
        if (tree["alternate"]["type"] == TreeNodeTypes.IfStatement) {
          // Recursively check all the elseif statements if they satisfy the given condition
          _evaluateIfStatement(tree["alternate"]);
        } else {
          // Finally evaluate the else statement
          _symbolTable.allocate();
          blockResult = _evaluateBlockStatements(tree["alternate"]["body"]);
          _symbolTable.free();
        }
      }
    }
    return blockResult;
  }

  _evaluateWhileStatement(Map<String, dynamic> tree) {
    /*
    Evaluates while statements
     */

    _symbolTable.allocate();

    // Evaluate init condition and determine result
    Map<String, dynamic> result = _evaluateTestCondition(tree["test"]);

    // Until the condition is satidfied, evaluate the block statements
    while (result["value"]) {
      var blockResult = _evaluateBlockStatements(tree["body"]["body"]);
      if (blockResult["break"] ?? false) {
        break;
      }

      // if (result["continue"]) continue; no need to check

      result = _evaluateTestCondition(tree["test"]);
    }
    _symbolTable.free();
  }

  _evaluatePrintStatement(Map<String, dynamic> tree) {
    /*
    Evaluates print statements
     */

    print(_evaluateStatement(tree["value"])["value"]);
  }

  _evaluateBreakStatement(Map<String, dynamic> tree) {
    /*
    Evaluates break statements
     */

    return {"break": true};
  }

  _evaluateContinueStatement(Map<String, dynamic> tree) {
    /*
    Evaluates continue statements statements
     */

    return {"continue": true};
  }

  _evaluateStatement(Map<String, dynamic> statement) {
    /*
    Evaluates different statements
     */
    _currLine = statement["line"];
    switch (statement["type"]) {
      case TreeNodeTypes.BreakStatement:
        return _evaluateBreakStatement(statement);
      case TreeNodeTypes.ContinueStatement:
        return _evaluateContinueStatement(statement);
      case TreeNodeTypes.VariableDeclaration:
        return _evaluateVariableDecleration(statement);
      case TreeNodeTypes.Assignment:
        _evaluateAssignment(statement);
        break;
      case TreeNodeTypes.ForStatement:
        _evaluateForStatement(statement);
        break;
      case TreeNodeTypes.IfStatement:
        return _evaluateIfStatement(statement);
      case TreeNodeTypes.WhileStatement:
        _evaluateWhileStatement(statement);
        break;
      case TreeNodeTypes.PrintStatement:
        _evaluatePrintStatement(statement);
        break;
      case TreeNodeTypes.BinaryExpression:
        return _evaluateBinaryExpression(statement);
      case TreeNodeTypes.LogicalExpression:
        return _evaluateLogicalExpression(statement);
      case TreeNodeTypes.UnaryExpression:
        return _evaluateUnaryExpression(statement);
      case TreeNodeTypes.Identifier:
        return _evaluateIdentifier(statement);
      case TreeNodeTypes.Number:
        return {"type": RunTimeTypes.Number, "value": statement["value"]};
      case TreeNodeTypes.Boolean:
        return {"type": RunTimeTypes.Boolean, "value": statement["value"]};
      default:
        break;
    }
  }
}
